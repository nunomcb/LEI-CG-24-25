#include "Mat4x4.h"

#include <algorithm>

float* Mat4x4::operator [](int col_idx) {
    return &data[col_idx * 4];
}

const float* Mat4x4::operator [](int col_idx) const {
    return &data[col_idx * 4];
}

float Mat4x4::get_max_scale_factor() const {
    const auto& t = *this;

    return std::max({
        Vector{t[0][0], t[0][1], t[0][2]}.length(),
        Vector{t[1][0], t[1][1], t[1][2]}.length(),
        Vector{t[2][0], t[2][1], t[2][2]}.length()
    });
}

Point Mat4x4::operator *(const Point& p) const {
    const auto& t = *this;

    float w = t[0][3]*p.x + t[1][3]*p.y + t[2][3]*p.z + t[3][3]*1;

    return Point(Vector{
        t[0][0]*p.x + t[1][0]*p.y + t[2][0]*p.z + t[3][0]*1,
        t[0][1]*p.x + t[1][1]*p.y + t[2][1]*p.z + t[3][1]*1,
        t[0][2]*p.x + t[1][2]*p.y + t[2][2]*p.z + t[3][2]*1
    } / w);
}

Mat4x4 Mat4x4::operator *(const Mat4x4& other) const {
    const auto& a = *this;
    const auto& b = other;
    
    Mat4x4 result{};

    for (int j = 0; j < 4; ++j) {
        for (int i = 0; i < 4; ++i) {
            float sum = 0.0f;

            for (int k = 0; k < 4; ++k) {
                sum += a[k][i] * b[j][k];
            }

            result[j][i] = sum;
        }
    }

    return result;
}

float Mat4x4::determinant() const {
    const auto& t = *this;

    return
        t[0][0] * (
            t[1][1] * (t[2][2]*t[3][3] - t[3][2]*t[2][3]) -
            t[2][1] * (t[1][2]*t[3][3] - t[3][2]*t[1][3]) +
            t[3][1] * (t[1][2]*t[2][3] - t[2][2]*t[1][3])
        ) -
        t[1][0] * (
            t[0][1] * (t[2][2]*t[3][3] - t[3][2]*t[2][3]) -
            t[2][1] * (t[0][2]*t[3][3] - t[3][2]*t[0][3]) +
            t[3][1] * (t[0][2]*t[2][3] - t[2][2]*t[0][3])
        ) +
        t[2][0] * (
            t[0][1] * (t[1][2]*t[3][3] - t[3][2]*t[1][3]) -
            t[1][1] * (t[0][2]*t[3][3] - t[3][2]*t[0][3]) +
            t[3][1] * (t[0][2]*t[1][3] - t[1][2]*t[0][3])
        ) -
        t[3][0] * (
            t[0][1] * (t[1][2]*t[2][3] - t[2][2]*t[1][3]) -
            t[1][1] * (t[0][2]*t[2][3] - t[2][2]*t[0][3]) +
            t[2][1] * (t[0][2]*t[1][3] - t[1][2]*t[0][3])
        );
}

Mat4x4 Mat4x4::inverse() const {
    const auto& t = *this;

    Mat4x4 inv;

    inv[0][0] =  t[1][1]*t[2][2]*t[3][3] - t[1][1]*t[2][3]*t[3][2] - t[2][1]*t[1][2]*t[3][3] + t[2][1]*t[1][3]*t[3][2] + t[3][1]*t[1][2]*t[2][3] - t[3][1]*t[1][3]*t[2][2];
    inv[1][0] = -t[1][0]*t[2][2]*t[3][3] + t[1][0]*t[2][3]*t[3][2] + t[2][0]*t[1][2]*t[3][3] - t[2][0]*t[1][3]*t[3][2] - t[3][0]*t[1][2]*t[2][3] + t[3][0]*t[1][3]*t[2][2];
    inv[2][0] =  t[1][0]*t[2][1]*t[3][3] - t[1][0]*t[2][3]*t[3][1] - t[2][0]*t[1][1]*t[3][3] + t[2][0]*t[1][3]*t[3][1] + t[3][0]*t[1][1]*t[2][3] - t[3][0]*t[1][3]*t[2][1];
    inv[3][0] = -t[1][0]*t[2][1]*t[3][2] + t[1][0]*t[2][2]*t[3][1] + t[2][0]*t[1][1]*t[3][2] - t[2][0]*t[1][2]*t[3][1] - t[3][0]*t[1][1]*t[2][2] + t[3][0]*t[1][2]*t[2][1];

    inv[0][1] = -t[0][1]*t[2][2]*t[3][3] + t[0][1]*t[2][3]*t[3][2] + t[2][1]*t[0][2]*t[3][3] - t[2][1]*t[0][3]*t[3][2] - t[3][1]*t[0][2]*t[2][3] + t[3][1]*t[0][3]*t[2][2];
    inv[1][1] =  t[0][0]*t[2][2]*t[3][3] - t[0][0]*t[2][3]*t[3][2] - t[2][0]*t[0][2]*t[3][3] + t[2][0]*t[0][3]*t[3][2] + t[3][0]*t[0][2]*t[2][3] - t[3][0]*t[0][3]*t[2][2];
    inv[2][1] = -t[0][0]*t[2][1]*t[3][3] + t[0][0]*t[2][3]*t[3][1] + t[2][0]*t[0][1]*t[3][3] - t[2][0]*t[0][3]*t[3][1] - t[3][0]*t[0][1]*t[2][3] + t[3][0]*t[0][3]*t[2][1];
    inv[3][1] =  t[0][0]*t[2][1]*t[3][2] - t[0][0]*t[2][2]*t[3][1] - t[2][0]*t[0][1]*t[3][2] + t[2][0]*t[0][2]*t[3][1] + t[3][0]*t[0][1]*t[2][2] - t[3][0]*t[0][2]*t[2][1];

    inv[0][2] =  t[0][1]*t[1][2]*t[3][3] - t[0][1]*t[1][3]*t[3][2] - t[1][1]*t[0][2]*t[3][3] + t[1][1]*t[0][3]*t[3][2] + t[3][1]*t[0][2]*t[1][3] - t[3][1]*t[0][3]*t[1][2];
    inv[1][2] = -t[0][0]*t[1][2]*t[3][3] + t[0][0]*t[1][3]*t[3][2] + t[1][0]*t[0][2]*t[3][3] - t[1][0]*t[0][3]*t[3][2] - t[3][0]*t[0][2]*t[1][3] + t[3][0]*t[0][3]*t[1][2];
    inv[2][2] =  t[0][0]*t[1][1]*t[3][3] - t[0][0]*t[1][3]*t[3][1] - t[1][0]*t[0][1]*t[3][3] + t[1][0]*t[0][3]*t[3][1] + t[3][0]*t[0][1]*t[1][3] - t[3][0]*t[0][3]*t[1][1];
    inv[3][2] = -t[0][0]*t[1][1]*t[3][2] + t[0][0]*t[1][2]*t[3][1] + t[1][0]*t[0][1]*t[3][2] - t[1][0]*t[0][2]*t[3][1] - t[3][0]*t[0][1]*t[1][2] + t[3][0]*t[0][2]*t[1][1];

    inv[0][3] = -t[0][1]*t[1][2]*t[2][3] + t[0][1]*t[1][3]*t[2][2] + t[1][1]*t[0][2]*t[2][3] - t[1][1]*t[0][3]*t[2][2] - t[2][1]*t[0][2]*t[1][3] + t[2][1]*t[0][3]*t[1][2];
    inv[1][3] =  t[0][0]*t[1][2]*t[2][3] - t[0][0]*t[1][3]*t[2][2] - t[1][0]*t[0][2]*t[2][3] + t[1][0]*t[0][3]*t[2][2] + t[2][0]*t[0][2]*t[1][3] - t[2][0]*t[0][3]*t[1][2];
    inv[2][3] = -t[0][0]*t[1][1]*t[2][3] + t[0][0]*t[1][3]*t[2][1] + t[1][0]*t[0][1]*t[2][3] - t[1][0]*t[0][3]*t[2][1] - t[2][0]*t[0][1]*t[1][3] + t[2][0]*t[0][3]*t[1][1];
    inv[3][3] =  t[0][0]*t[1][1]*t[2][2] - t[0][0]*t[1][2]*t[2][1] - t[1][0]*t[0][1]*t[2][2] + t[1][0]*t[0][2]*t[2][1] + t[2][0]*t[0][1]*t[1][2] - t[2][0]*t[0][2]*t[1][1];

    const float det = t[0][0]*inv[0][0] + t[1][0]*inv[0][1] + t[2][0]*inv[0][2] + t[3][0]*inv[0][3];
    const float inv_det = 1.0f / det;

    for (float& i : inv.data) {
        i *= inv_det;
    }

    return inv;
}
