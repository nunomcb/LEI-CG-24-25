#include "model/serialise/ObjSerialiser.h"
#include "model/ModelBuilder.h"
#include "model/Point.h"
#include "model/TextureCoord.h"
#include "model/Vector.h"
#include "model/Vertex.h"

#include <stdexcept>
#include <sstream>
#include <iostream>
#include <vector>
#include <array>


void ObjSerialiser::serialise(Model& model, std::ostream& out_stream) {
    out_stream << "# Generated by CG Project\n";

    const size_t model_vertex_count = model.get_vertex_count();
    const Vertex* model_vertices = model.get_vertices();

    std::vector<Point> obj_positions;
    std::vector<Vector> obj_normals;
    std::vector<TextureCoord> obj_tex_coords;

    std::map<Point, unsigned int> pos_to_obj_idx;
    std::map<Vector, unsigned int> norm_to_obj_idx;
    std::map<TextureCoord, unsigned int> tc_to_obj_idx;

    for (size_t i = 0; i < model_vertex_count; ++i) {
        const Vertex& v = model_vertices[i];

        if (pos_to_obj_idx.find(v.position) == pos_to_obj_idx.end()) {
            obj_positions.push_back(v.position);
            pos_to_obj_idx[v.position] = static_cast<unsigned int>(obj_positions.size() - 1);
        }

        if (norm_to_obj_idx.find(v.normal) == norm_to_obj_idx.end()) {
            obj_normals.push_back(v.normal);
            norm_to_obj_idx[v.normal] = static_cast<unsigned int>(obj_normals.size() - 1);
        }

        if (tc_to_obj_idx.find(v.texture_coord) == tc_to_obj_idx.end()) {
            obj_tex_coords.push_back(v.texture_coord);
            tc_to_obj_idx[v.texture_coord] = static_cast<unsigned int>(obj_tex_coords.size() - 1);
        }
    }
    
    for (const auto& pos : obj_positions) {
        out_stream << "v " << pos.x << " " << pos.y << " " << pos.z << "\n";
    }

    for (const auto& norm : obj_normals) {
        out_stream << "vn " << norm.x << " " << norm.y << " " << norm.z << "\n";
    }

    for (const auto& tc : obj_tex_coords) {
        out_stream << "vt " << tc.u << " " << tc.v << "\n";
    }

    const size_t model_index_count = model.get_index_count();
    const unsigned int* model_indices = model.get_indices();

    for (size_t i = 0; i < model_index_count; i += 3) {
        out_stream << "f";

        for (size_t j = 0; j < 3; ++j) {
            unsigned int current_model_vertex_idx = model_indices[i + j];
            const Vertex& current_vertex_attrs = model_vertices[current_model_vertex_idx];

            unsigned int obj_pos_idx = pos_to_obj_idx.at(current_vertex_attrs.position) + 1;
            unsigned int obj_norm_idx = norm_to_obj_idx.at(current_vertex_attrs.normal) + 1;
            unsigned int obj_tc_idx = tc_to_obj_idx.at(current_vertex_attrs.texture_coord) + 1;

            out_stream << " " << obj_pos_idx << "/" << obj_tc_idx << "/" << obj_norm_idx;
        }
        
        out_stream << "\n";
    }
}

Model ObjSerialiser::deserialise(std::istream& in_stream) {
    std::vector<Point> file_points;
    std::vector<Vector> file_normals;
    std::vector<TextureCoord> file_tex_coords;

    ModelBuilder builder;

    std::string line;
    int line_num = 0;

    while (std::getline(in_stream, line)) {
        line_num++;
        std::stringstream ss(line);
        std::string line_type;
        ss >> line_type;

        if (line_type == "v") {
            float x, y, z;

            ss >> x >> y >> z;

            file_points.emplace_back(Point{x, y, z});
        }
        else if (line_type == "vt") {
            float u, v;

            ss >> u >> v;

            file_tex_coords.emplace_back(TextureCoord{u, v});
        }
        else if (line_type == "vn") {
            float x, y, z;

            ss >> x >> y >> z;

            file_normals.emplace_back(Vector{x, y, z});
        }
        else if (line_type == "f") {
            std::vector<unsigned int> face_v_indices;
            std::vector<unsigned int> face_vn_indices;
            std::vector<unsigned int> face_vt_indices;

            std::string face_vertex;
            while (ss >> face_vertex) {
                unsigned int v_idx, vt_idx, vn_idx;

                int parts = sscanf(face_vertex.c_str(), "%u/%u/%u", &v_idx, &vt_idx, &vn_idx);

                if (parts < 2) {
                    parts = sscanf(face_vertex.c_str(), "%u//%u", &v_idx, &vn_idx);

                    if (parts == 2) {
                        vt_idx = 0;
                    }
                } else if (parts == 2) {
                    vn_idx = 0;
                }

                if (v_idx == 0) {
                    throw std::runtime_error("Missing v idx");
                };

                if (vn_idx == 0) {
                    throw std::runtime_error("Missing n idx");
                }

                face_v_indices.push_back(v_idx - 1);
                face_vn_indices.push_back(vn_idx - 1);
                face_vt_indices.push_back(vt_idx > 0 ? vt_idx - 1 : 0);
            }

            for (size_t i = 1; i < face_v_indices.size() - 1; ++i) {
                size_t idx0 = 0;
                size_t idx1 = i;
                size_t idx2 = i + 1;

                unsigned int v_file_idx0 = face_v_indices[idx0];
                unsigned int v_file_idx1 = face_v_indices[idx1];
                unsigned int v_file_idx2 = face_v_indices[idx2];

                unsigned int vn_file_idx0 = face_vn_indices[idx0];
                unsigned int vn_file_idx1 = face_vn_indices[idx1];
                unsigned int vn_file_idx2 = face_vn_indices[idx2];

                unsigned int vt_file_idx0 = face_vt_indices[idx0];
                unsigned int vt_file_idx1 = face_vt_indices[idx1];
                unsigned int vt_file_idx2 = face_vt_indices[idx2];

                Vector n0 = file_normals[vn_file_idx0];
                Vector n1 = file_normals[vn_file_idx1];
                Vector n2 = file_normals[vn_file_idx2];

                TextureCoord tc0 = (vt_file_idx0 < file_tex_coords.size()) ? file_tex_coords[vt_file_idx0] : TextureCoord{0,0};
                TextureCoord tc1 = (vt_file_idx1 < file_tex_coords.size()) ? file_tex_coords[vt_file_idx1] : TextureCoord{0,0};
                TextureCoord tc2 = (vt_file_idx2 < file_tex_coords.size()) ? file_tex_coords[vt_file_idx2] : TextureCoord{0,0};

                Vertex vert0(file_points[v_file_idx0], n0, tc0);
                Vertex vert1(file_points[v_file_idx1], n1, tc1);
                Vertex vert2(file_points[v_file_idx2], n2, tc2);

                builder.push({vert0, vert1, vert2});
            }
        }
    }

    return builder.build();
}
